---
title: "Draw a function"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Draw a function}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Your first diagram

We use the function `flow_view()` to draw a function as a diagram. It can be any
function, packaged or user made, as long as it has a body.

Take the `rle` function from base R, its role is to (citing `?rle`):

> Compute the lengths and values of runs of equal values in a vector

For instance:

```{r}
rle(c(3, 3, 3, 1, 6 , 6))
```

And its code is :

```{r}
rle
```

The function is not overly complex but its logic is not obvious at
first glance. `flow_view()` helps us sort it out.

```{r, fig.width=8, fig.height=8, fig.align = "center"}
library(flow)
flow_view(rle)
```

`if` statements always branch into two paths, whether an `else` clause is present
or not. `for`, `while`, and `repeat` loops are also supported.

The colored circles are exit points, orange for errors (using `stop()`), 
green for returned values (using `return()`) or just reaching the end of the function.

There you go, you know all you need to get started! And for this example and many 
this will be pretty much all you need. 

For other cases we propose the following features.

## Export to pdf, png, jpg, or html

*{flow}* supports saving your diagrams to various formats by using the argument `out`.

If `out` is a path, the diagram will be saved there, 
using the file extension to determine the format. For instance:

```{r, eval = FALSE}
flow_view(rle, out = "diagrams/rle.png")
```

If you don't want to save at a specific location but just want to open your
diagram in a different format, use the shorthands `"pdf"`, `"png"`, `"jpg"`,
`"jpeg"`, `"htm"` , `"html"` and `flow_view()` will save it  to a temporary 
location, print and return its url, and open this location using `browseURL` (which opens
your files with your relevant default viewer). For instance:

```{r, eval = FALSE}
flow_view(rle, out = "html")
#> The diagram was saved to '*******.html'
#> [1] "*******.html"
```

When exporting to *html*, 
you might sometimes want to use SVG rendering by using the argument `svg = TRUE`. 
A difference is that it makes text selectable.

## Display comments as code block headers

Comments and diagrams are two nice ways of understanding code, so why not use 
them together? This is done by using the `prefix` argument.
Comments in your call will be treated as block headers if they start with the
given prefix.

Let's rework our `rle` function by adding helpful comments, prefixed by `"##"` :

```{r, fig.width=8, fig.height=8, fig.align = "center"}
rle <- function (x) 
{
  # A rle object is a list containing elements length and value. It is
  # assigned a class "rle"
  
    ## is argument of wrong type ?
    if (!is.vector(x) && !is.list(x)) 
        stop("'x' must be a vector of an atomic type")
    n <- length(x)
    if (n == 0L) {
        ## return a rle object with zero length elements
        return(structure(list(lengths = integer(), values = x), 
            class = "rle"))
    }
    ## compute index of elements that are distinct from the next
    y <- x[-1L] != x[-n]
    i <- c(which(y | is.na(y)), n)
    ## compute the final object
    structure(list(lengths = diff(c(0L, i)), values = x[i]), 
        class = "rle")
}

flow_view(rle, prefix = "##")
```

We see that : 

* The unprefixed comments are ignored.
* Prefixed comments right before control flow calls (here `if`) will serve
as headers for control flow header blocks.
* Prefixed comments before other code will serve as headers for the subsequent
code chunks.
* Adding special comments in the middle of standard code,as we did in the last
block, will split the block and use the comment as the header of the new block.

Note the we used `{}` after `if (n == 0L)` compared to the original code.
This is a current limitation, special comments are viewed as code we need the 
`{}` to keep both following lines in the `if` condition.

Misplaced comments, which cannot be used as headers, will be ignored, such as in :

```{r, eval = FALSE}
c(
  ## comment
  1)
```

Nothing prevents you from choosing `prefix = "#"`, in that case all comments will
be considered as headers.

## Display or hide the code

If you're mainly interested in the logical structure of your code you can choose
to remove the code from standard blocks, and have a lighter output :

```{r, fig.width=8, fig.height=8, fig.align = "center"}
flow_view(rle, code = FALSE)
```
If you defined headers as we did in the previous section you can see the logic
almost as if it was pseudo code :

```{r, fig.width=8, fig.height=8, fig.align = "center"}
flow_view(rle, prefix = "##", code = FALSE)
```

An intermediate is to use `code = NA`, to show only header whenever they are
available, note that in that case even the `if` block's text was simplified : 

```{r, fig.width=8, fig.height=8, fig.align = "center"}
flow_view(rle, prefix = "##", code = NA)
```

## Narrow down a wide diagram

In our simple example you can see that the main branch has shifted from the
center after the first `if` block. This is not a problem here but for bigger
diagrams you might have the issue of the diagram shifting right significantly.
This can be undesirable for web pages, pdf documents etc where we'd like
to have everything fit on the width of the page whenever possible. 

The `narrow` argument makes it possible, at the cost of drawing a longer diagram. 

```{r, fig.width=8, fig.height=8, fig.align = "center"}
flow_view(rle, narrow = TRUE)
```

## Display nested functions as diagrams

A function's body often contains other function definitions, sometimes anonymous,
sometimes assigned to a variable.

The `nested_fun` argument allows you to explore any of those.

A good example is the base function `bquote()`, it defines a couple functions,
and the diagram that *{flow}* draws is not fully satisfactory.

```{r, fig.width=8, fig.height=8, fig.align = "center"}
flow_view(bquote)
```

*{flow}* detects the function definitions and proposes you to
investigate them. Let's see what `unquote()` is about.

```{r, fig.width=8, fig.height=8, fig.align = "center"}
flow_view(bquote, nested_fun = "unquote")
```


## Other arguments

`swap`, `TRUE` by default, edits the statements like : 

```{r, eval=FALSE}
x <- if(cond) this else that
```

into

```{r, eval=FALSE}
if(cond) x <- this else x <- that
```

The reason is that the latter version can be represented by a diagram while
the first can't. The logic stays the same however. If you want to make sure 
you see the original code, use `swap = FALSE`.

`engine_opts` is used to pass arguments to engine specific functions.

In the most general case `engine_opts` is a list containing optional sub-lists named
`"nomnoml"`, `"plantuml"`, and `"htmlwidgets"`.

- The items of the `nomnoml`
 sub-list will be forwarded to `nomnoml:::build_nomnoml_code()`, unexported but
 documented in `?build_nomnoml_code`, in order to alter
 *nomnoml* diagrams. For instance `fontSize`, `direction = "right"` to have a left to right
 diagram, `ranker = "longest-path"` to see have exit points at the bottom...
 - The items of the `plantuml` sub-list will be forwarded to `plantuml:::plot.plantuml()`,
 , in order to alter  *plantuml* diagrams.
 see `?plantuml:::plot.plantuml` and `?plantuml::plantuml_run`
 - The items of the `htmlwidgets` sub-list will be forwarded to
 `htmlwidgets::createWidget()` or `htmlwidgets::saveWidget()`, which are used by
 the *nomnoml* engine.

If this structure is not found, the items of `engine_opts` will be forwarded
to `nomnoml:::build_nomnoml_code()` if the engine is `"nomnoml"`, and
`plantuml:::plot.plantuml` if the engine is `"plantuml"`

For instance here's a custom representation of `rle`

```{r, fig.width=8, fig.height=8, fig.align = "center"}
flow_view(rle, engine_opts = c(ranker = "longest-path", direction = "right"))
```

